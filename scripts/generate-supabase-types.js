#!/usr/bin/env node
/**
 * TypeScript Type Generation Script for GoalStake
 * 
 * This script generates TypeScript types directly from your Supabase database schema.
 * It uses the Supabase CLI to fetch the current database schema and generate
 * appropriate TypeScript types for use in your application.
 * 
 * Usage:
 *   node scripts/generate-supabase-types.js [environment]
 * 
 * Environment:
 *   - dev (default)
 *   - staging
 *   - prod
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');
const dotenv = require('dotenv');
const { program } = require('commander');

// Setup command line arguments
program
  .name('generate-supabase-types')
  .description('GoalStake TypeScript type generator')
  .version('1.0.0')
  .argument('[environment]', 'Environment to generate types from', 'dev')
  .option('-o, --output <path>', 'Output file path', 'types/supabase.ts')
  .option('-s, --schemas <schemas>', 'Comma-separated list of schemas to include', 'public,storage')
  .option('-v, --verbose', 'Show detailed logs during generation')
  .parse(process.argv);

const options = program.opts();
const environment = program.args[0] || 'dev';

// Load environment variables
const envFile = `.env.${environment}`;
if (!fs.existsSync(envFile)) {
  console.error(`Error: Environment file ${envFile} not found.`);
  process.exit(1);
}

dotenv.config({ path: envFile });

// Required environment variables
const SUPABASE_URL = process.env.NEXT_PUBLIC_SUPABASE_URL;
const SUPABASE_SERVICE_KEY = process.env.SUPABASE_SERVICE_ROLE_KEY;
const SUPABASE_PROJECT_ID = SUPABASE_URL ? SUPABASE_URL.match(/https:\/\/([^.]+)/)?.[1] : null;

if (!SUPABASE_URL || !SUPABASE_SERVICE_KEY || !SUPABASE_PROJECT_ID) {
  console.error('Error: Required environment variables are missing.');
  console.error('Make sure NEXT_PUBLIC_SUPABASE_URL and SUPABASE_SERVICE_ROLE_KEY are set in your .env file.');
  process.exit(1);
}

// Ensure output directory exists
const outputFile = options.output;
const outputDir = path.dirname(outputFile);

if (!fs.existsSync(outputDir)) {
  if (options.verbose) {
    console.log(`Creating directory ${outputDir}`);
  }
  fs.mkdirSync(outputDir, { recursive: true });
}

/**
 * Generate TypeScript types using Supabase CLI
 */
function generateTypes() {
  console.log(`\nüöÄ Generating TypeScript types from ${environment} Supabase schema\n`);
  
  try {
    // Create a temporary config file for the Supabase CLI
    const tempConfigPath = path.join(__dirname, '..', 'supabase', 'config.json');
    const config = {
      project_id: SUPABASE_PROJECT_ID,
      api: {
        url: SUPABASE_URL,
        service_role_key: SUPABASE_SERVICE_KEY
      }
    };
    
    fs.writeFileSync(tempConfigPath, JSON.stringify(config, null, 2));
    
    if (options.verbose) {
      console.log('Created temporary Supabase config');
    }
    
    // Create header content for the types file
    const headerContent = `/**
 * GoalStake Supabase Types
 * 
 * Auto-generated types from the Supabase schema.
 * Generated on: ${new Date().toISOString()}
 * Environment: ${environment}
 * 
 * DO NOT EDIT THIS FILE MANUALLY!
 * Run \`npm run generate:types\` to regenerate this file when your schema changes.
 */

`;
    
    // Run the Supabase types generation command
    console.log('Fetching database schema from Supabase...');
    const schemas = options.schemas.split(',').map(s => s.trim()).join(',');
    
    const typesCommand = `npx supabase gen types typescript --project-id ${SUPABASE_PROJECT_ID} --schema ${schemas}`;
    
    if (options.verbose) {
      console.log(`Executing: ${typesCommand}`);
    }
    
    const typesOutput = execSync(typesCommand, { encoding: 'utf8' });
    
    // Generate helper types for better DX
    const helperTypes = `
// Helper types for better developer experience

/**
 * Row-level types for tables
 */
export type Profile = Database['public']['Tables']['profiles']['Row'];
export type Challenge = Database['public']['Tables']['challenges']['Row'];
export type Participant = Database['public']['Tables']['participants']['Row'];
export type Verification = Database['public']['Tables']['verifications']['Row'];
export type Stake = Database['public']['Tables']['stakes']['Row'];
export type Transaction = Database['public']['Tables']['transactions']['Row'];
export type Notification = Database['public']['Tables']['notifications']['Row'];

/**
 * Insert types for tables
 */
export type ProfileInsert = Database['public']['Tables']['profiles']['Insert'];
export type ChallengeInsert = Database['public']['Tables']['challenges']['Insert'];
export type ParticipantInsert = Database['public']['Tables']['participants']['Insert'];
export type VerificationInsert = Database['public']['Tables']['verifications']['Insert'];
export type StakeInsert = Database['public']['Tables']['stakes']['Insert'];
export type TransactionInsert = Database['public']['Tables']['transactions']['Insert'];
export type NotificationInsert = Database['public']['Tables']['notifications']['Insert'];

/**
 * Update types for tables
 */
export type ProfileUpdate = Database['public']['Tables']['profiles']['Update'];
export type ChallengeUpdate = Database['public']['Tables']['challenges']['Update'];
export type ParticipantUpdate = Database['public']['Tables']['participants']['Update'];
export type VerificationUpdate = Database['public']['Tables']['verifications']['Update'];
export type StakeUpdate = Database['public']['Tables']['stakes']['Update'];
export type TransactionUpdate = Database['public']['Tables']['transactions']['Update'];
export type NotificationUpdate = Database['public']['Tables']['notifications']['Update'];

/**
 * Enum types
 */
export type ChallengeCategory = Database['public']['Enums']['challenge_category'];
export type ChallengeStatus = Database['public']['Enums']['challenge_status'];
export type ChallengeVisibility = Database['public']['Enums']['challenge_visibility'];
export type ParticipantStatus = Database['public']['Enums']['participant_status'];
export type StakeModel = Database['public']['Enums']['stake_model'];
export type TransactionStatus = Database['public']['Enums']['transaction_status'];
export type TransactionType = Database['public']['Enums']['transaction_type'];
export type VerificationFrequency = Database['public']['Enums']['verification_frequency'];
export type VerificationStatus = Database['public']['Enums']['verification_status'];

/**
 * View types
 */
export type ActiveChallenge = Database['public']['Views']['active_challenges']['Row'];
export type UserStats = Database['public']['Views']['user_stats']['Row'];
`;
    
    // Write the types to the output file
    fs.writeFileSync(outputFile, headerContent + typesOutput + helperTypes);
    
    // Clean up the temporary config file
    fs.unlinkSync(tempConfigPath);
    
    console.log(`\n‚úÖ TypeScript types successfully generated at ${outputFile}`);
    console.log('Types include:');
    console.log('  - Database schema types');
    console.log('  - Row types for all tables');
    console.log('  - Insert/Update types for all tables');
    console.log('  - Enum types');
    console.log('  - View types\n');
    
  } catch (error) {
    console.error(`\n‚ùå Failed to generate TypeScript types: ${error.message}`);
    
    if (error.stdout) {
      console.error('Command output:', error.stdout.toString());
    }
    
    if (error.stderr) {
      console.error('Command error output:', error.stderr.toString());
    }
    
    process.exit(1);
  }
}

// Execute the type generation
generateTypes(); 